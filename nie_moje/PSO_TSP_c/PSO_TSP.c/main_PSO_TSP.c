/* Looking for a minimum Hamiltonian cycle in a graph (Traveling Salesman Problem)using Particle Swarm OptimizationMaurice.Clerc@WriteMe.comFebruary 2000 Version 4.2(WARNING: if you have used version 2.x, this one works _very_ differently)Description-----------Yet_another_TSP_algorithm. In order to solve the Traveling Salesman Problem, this program uses Particle Swarm Optimization.If there is _no_ Hamilton cycle, it usually finds at least a Hamilton _path_.If there is even no Hamilton path, it usually finds the longest path (in terms of node number).Due to the nature of PSO, you can't be _sure_ to obtain the best solution, but quite often you have at least a good one very rapidly (typically 5 iterations for a 9-graph).You can either generate a graph randomly, or read one from a text file.Download--------Well, you have it, havn't you ?For more information and last "public" version see http://www.mauriceclerc.net, Math stuff for PSO, Discrete PSOEXPLANATION===========In classical PSO, a  quite general system of equations is, for each particle				v(t+1) = alpha*v(t) +(beta*phi)*(pig-x)					Equ. 1				x(t+1) = pig + gamma*v(t) + (delta-eta*phi)*(pig-x)		Equ. 2				pi:  previous best position of the particlepg:  globel best position (best particle in the neighbourhoud)	pig: (pi+pg)/2			 v(t) is the "velocity" at time step tx(t) is the "position" at time step talpha and phi are coefficients defining how each particle "trusts" itself and its neighbours. Note: in the most general case, you have phi1 for pi and phi2 for pg.Graph-particles--------------------G is a valuated graph with N nodes n_i(for visualization, it is better to have integer values. No arc <=> negative value )The position of a particle is defined as a sequence of N+1 nodes:						x=(x_1,..., x_N+1),with x_1=x_N+1. It means a particle is a cycle, valid or not (some arcs x_i=>x_i+1 may be not in the graph G)What could be the "velocity" ?  If we note that "applying" a velocity to a position we find another position,we can define a velocity as a list of consecutive permutations (node i <=> node j) 				v=( (n_1,n_j),... (n_i,n_k),... (n_N,n_l))In particular, it means that the "difference" between two particle is a velocity.Now, we have to define some operations :p + v				  	position + velocity => position	 		(subroutine pos_plus_vel)coeff*v					coeff*velocity => velocity				(subroutine coeff_times_vel)v + v'					velocity + velocity => velocity			(subroutine vel_plus_vel)There is also an underlying distance function, but we do not have to compute it,unless we use it in the Nohope test (swarm too small)d(x-x'): (particle,particle) => real number Concerning the distance between two particles p1 and p2, all what we really need is to be sure that when p1 is moving "towards" p2, it is decreasing.   Objective function   (subroutine f)-------------------We define a real function f on the set of particles so that its minimumsare possible solutions (Hamiltonian cycles)Intuitively, if we consider a particle, the easiest way is to add the arc values of (x_i,x_i+1).Now, there are two "taxes" to add:- when this arc doesn't exist  					(subroutine tax_no_arc)- when a node is not used in the particle		(subroutine tax_no_node)The main difficulty is to find  an objective functionf and a distance d so that they are correlated.That means if you move a particle p1 towards a particle p2 (decreasing d(p1,p2)),so, at least when we are "near" of p2, whe should have abs(f(p1)-f(p2)) decreasing. In practice, the point is the way particles are moving (cf. move_towards()) Improvements: Nohope/Rehope, Queen (see the paper The Swarm and the Queen for details)-------------When the swarm becomes "too small" there is "no hope" to reach a solution. In such a case, the swarm is reinitialized, just keeping the best position found so far.Note 1: you may use the "queen" option. The queen "summarizes" the swarm and is hopefully located in a better position than any particle in the swarm. It works sometimes, but it is not very clearif it is indeed worthwhile to spend computer time to compute it.So, the question is still open:Is a queen useful ? (just a mathematical question, of course).An example of parameters--------------------------Random generationGraph size: 15 nodes Number of different values: 1 (so you know) Graph density: 65Swarm size: 15Neighbourhood size: 7   (not too much, for you could find the best result by chance						at the initialization: it would be not "fair")Max iterations: 10 (it should stop before, anyway)In order to evaluate the algorithm, you should run it in "Debug mode", so thatyou have the number of arithmetical/logical operations performed Compiling the program-------------------It is written in ANSI C, except the visualization part.If you compiler does not understand these instructions, just remove them.But if by chance you have a Mac, you should use the free compiler Leonardohttp://www.dis.uniroma1.it/~demetres/Leonardo/so that you can see the nice graphs!Known problems--------------1) For small graphs, random initialization may give too often the same particle. In particular,during the process, when the swarm is too reduced, Rehope process may not work => no possibilityto continue. Subroutine init_swarm has to be improved.2) Still need some tricks to reduce computer time: for a N-graph,    it increases about like N^2log(N).3) As usually for such algorithms, you can rarely be sure to reach the global optimum. Note that the program performs some preliminary classical tests, in order to know if there isor not at least a solution. Also, if all arc values are the same, it stops when the best solution(if exists) is indeed reached). *//* Useful headers */#include <math.h>#include <stdio.h>#include <string.h>#include <stdlib.h>#include <syscall.h>// Define and structures#include "def_and_struc.h"/* Subroutines definitions */#include "math_add.h"#include "display.h"#include "graph_tools.h"#include "swarm_tools.h"#include "particle_tools.h"struct coeff 			convergence_case(float kappa, float phi);/* Global variables */#include "global_var.c"int q[Nmax]; // When using f_Sort, integer numbers to sortstruct particle best_solution;FILE *f_trace;/* Visualizations . WARNING:  NOT   ANSI C  */#include "visualization.c"/* =============================== Subroutines ================================== */#include "math_add.c"#include "display.c"#include "graph_tools.c"#include "swarm_tools.c"#include "particle_tools.c"#include "f_TSP.c"#include "display_position_TSP.c"//#include "f_Sort.c"//#include "display_position_Sort.c"struct coeff convergence_case(float kappa, float phi);/* =============================================================================== */void main(){FILE *f_graph; /* File containing the graph, if you use this option */FILE *f_run; /* To save swarm positions, for each iteration */struct particle	best_hood; /* Best particle in the neighbourhood */int				choice;struct coeff	coeff;int				density;float			kappa;int				i;int				iter,iter_min,iter_max;char			graph[256]; /* Graph file name */float			max_eval;int				max_iter;float			min_tour;int				move_type; // See move_towards()float			nohope;int				parallel;float			phi;int				rehope; // For test without rehope option (value 0, 1 else)struct particle	solution;int				swarm_size;float			target;int				vmax;float			x; // Mainly for type conversionint				xi;f_trace=fopen("trace.txt","w");G.l_max=10;G.l_min=1; // Just for initial visualization/*----------------- SOME PARAMETERS -------------- */#include "param.c"goto shunt_Sort;// When using f_Sort ...G.N=10;save=0;for (i=1;i<G.N;i++)	{	q[i]=alea(0,5*G.N);	}q[0]=0;q[G.N]=0;goto parameters;shunt_Sort:if (save==0) goto graph;/*-------------------------- */printf("\nChoose the file to save the run, please");if (PutFileDialog(graph)==0) exit(printf("    Cancelled\n"));puts("\nChosen file:");puts(graph);f_run=fopen(graph,"w");/*-------------------------- */graph:printf("\n 0 = read a file containing the graph description");printf("\n 1 = generate a graph randomly");printf("\n Your choice ? :");scanf("%i",&choice);if (choice==1)	{	printf("\n Number of nodes ? (<=%i): ",Nmax);	scanf("%i",&G.N);	printf("\n How many different arc values ?: ");	scanf("%i",&vmax);	printf("\n Graph density ? [1,100]: ");	scanf("%i",&density);	density=MIN(MAX(1,density),100);		G=random_graph(G.N,vmax,density);	goto graph_study;	}/* Read the valuated graph  (Note: value 0 <=> no arc) */graph_name:printf("\nChoose the file containing the graph, please");if (GetFileDialog(graph)==0) exit(printf("Cancelled\n"));puts("\nChosen file:");puts(graph);f_graph=fopen(graph,"r");G=read_graph(f_graph,trace);printf("\n Just looking for Hamilton cycles  ? (y/n): ");scanf("%s",&answer);if (answer[0]=='y') G=TSP_to_Hamilton(G);/*------------------------------ */graph_study:check_Hamilton_cycle(G);G=graph_min_max(G); /* Compute the max and the min arc values, and the number of edges */val=graph_min_tour(G); // Smaller than or equal to the best tourmin_tour=val.min;parameters:/* Initialization of particles (states) */printf("\n Swarm size  ? (max = %i) ",Max_size);x=G.N; xi=x-1;printf("\n      (suggestion %i): ",xi);scanf("%i",&swarm_size);swarm_size=MAX(1,MIN(swarm_size,Max_size));sw1.size=swarm_size;printf("\n With queens ? (y/n): ");scanf("%s",&answer);if (answer[0]=='y') queens=1; else queens=0;/* Define the neighbourhood size (including the particle itself */printf("\n Neighbourhood size  ? (max = %i) ",sw1.size);xi=MIN(4,sw1.size);printf("\n       (suggestion %i): ",xi);scanf("%i",&hood);hood=MAX(1,MIN(hood,sw1.size));/* ======================================================== HERE IS THE ALGORITHM */iter_min=0;eval_f=0;auto_move_type=-1;/*-------------------------------- Initialization */	/* Initialize the swarm for the first iteration */		printf("\n Trace level for initialization  ? (0,1,2,3,4)  ");	scanf("%i",&trace);		sw1=init_swarm(swarm_size,G,trace); 	if(sw1.size<swarm_size) 		{		printf("\n Can't generate a swarm");		goto error_end;		}	best_matrice=best_visu(best_best,G); /* Just for visualization */	if (save!=0) save_swarm(f_run,sw1); /* Save the run as text file */goto shunt_map;//--------------------- Just for partial Mapf_trace=fopen("trace.txt","w");printf("\n best particle ?: ");for (i=0;i<G.N+1;i++)	{	scanf("%i ",&best_solution.x.s[i]);	}best_solution.x.size=G.N;best_solution.rank=-1;shunt_map:best_solution=init; // (Temporary)best_solution.v.size=0;best_solution.f=f(best_solution,-1,-1);display_position(best_solution,1);//------------------------		/*-------------------------------- Iterations *//* Iterations */printf("\n Max tour evaluations  ?  ");scanf("%f",&max_eval);iterations:printf("\n Max iterations  ? (0 => end)  ");scanf("%i",&max_iter);if (max_iter==0) return;printf("\n  kappa value ? (suggestion: 0.5): "); // Constriction coefficients. See move_towardsscanf("%f",&kappa);printf("\n  phi value ? (suggestion: 4):  ");scanf("%f",&phi);coeff=convergence_case(kappa,phi);printf("\n Hood type  ? (0 = social (quick) 1 = physical (long)\n (suggestion: 0):  ");scanf(" %i",&hood_type);printf("\n Move type  ? (0,1,2,3,4,5) (suggestion: 3):  ");scanf("%i",&move_type);printf("\n Auto-move type  ? (0,1,2,3.  9 if adaptive) (suggestion: %i):  ", MIN(2,auto_move_type+1));scanf("%i",&auto_move_type);printf("\n Target  ? (suggestion %.0f) ",min_tour);scanf("%f",&target);printf("\n Trace level  ? (0,1,2,3,4)  ");scanf("%i",&trace);iter_max=iter_min+max_iter;for (iter=iter_min;iter<iter_max;iter++)	{		printf("\n\n ITERATION %i, swarm size %i, best sure possible value %f",iter,sw1.size,extra_best.f);	display_iter(iter,eval_f,swarm_size, G.N);	if (extra_best.f<same_best_val) 		{		same_best=0;		same_best_val=extra_best.f;		}	else		{		same_best=same_best+1;		}			printf("\n same_best_val %f,  %i times",same_best_val,same_best);		if (rehope!=0) 		{		if (levelling>0) levelling=levelling-1;		if (reduce>0) sw1=reduce_swarm(sw1);		if (no_hope(sw1,swarm_size,adaptive,nohope,hood)==1)			{			sw1=re_hope(sw1,swarm_size,trace,auto_move_type,monotony,levelling); /* No-hope/Re-hope process, if the swarm becomes too small */			}		}			/* For each particle i, find the best in the neighbourhood (or the local queen) */	for (i=0;i<sw1.size;i++)		{				best_hood=best_neighbour(sw1,sw1.p[i],hood,queens,hood_type,monotony,equiv_v,trace);			if (best_hood.f<best_best.f) best_best=best_hood; /* Best of the best before the move */			/* Move "between" its own position and the one of the best neighbour  */			if (parallel==1)			{			sw2.p[i]=move_towards(sw1.p[i],best_hood,coeff,move_type,explicit_vel,conv_case,equiv_v,trace);						if (sw2.p[i].f<best_best.f)/* Best of the best after the move */				{ 				best_best=sw2.p[i];				}			}		else			{			sw1.p[i]=move_towards(sw1.p[i],best_hood,coeff,move_type,explicit_vel,conv_case,equiv_v,trace);						if (sw1.p[i].f<best_best.f)/* Best of the best after the move */				{ 				best_best=sw1.p[i];				}			}				 		if (best_best.f<=G.l_min*G.N || extra_best.f<=G.l_min*G.N ) /* Sometimes, we _know_ this is the global minimum */			{			printf("\n\n Particle %i.  There is no better solution than ",i+1);			goto end;			}				if (best_best.f<=target || extra_best.f<=target)			{			printf("\n Target: %f",target);			goto end;				}		}				if (parallel==1)		{			sw2.size=sw1.size;/* Move "really" the swarm */		sw1=sw2;		}					if (trace>0) display_swarm(sw1);			best_matrice=best_visu(best_best,G); /* Just for visualization */	if (save!=0) save_swarm(f_run,sw1);			if (trace>1) printf("\n Temporary solution:");display_solution(best_best);			if (eval_f>=max_eval)		{		printf("\n\n Stop at max eval %f",eval_f);		goto end;		}		if (best_best.f<=G.l_min*G.N || extra_best.f<=G.l_min*G.N )		{		printf("\n\n There is no better solution than ");		goto end;		}						}end:	/* Give the best position (sequence) found */	printf("\n Best solution found:");if (best_best.f<=extra_best.f)	{solution=best_best;}else	{ solution=extra_best;}		display_solution(solution);display_iter(iter,eval_f,swarm_size,G.N);best_matrice=best_visu(solution,G); /* Just for visualization */sw1.p[sw1.size]=extra_best;sw1.size=sw1.size+1;if (save!=0) save_swarm(f_run,sw1);save_swarm(f_trace,sw1);if (trace>0) display_swarm(sw1);iter_min=iter_max;goto iterations;	return;error_end:printf("\n Sorry, I give up");}/* ============================= Subroutines ================== *//*------------------------------------------------------------------- 	CONVERGENCE_CASE */struct coeff convergence_case(float kappa, float phi)//*****************************General case// Coefficients of the generalized iterative representation// The matrix of the system is M//       [alpha       beta*phi   ]//       [-gamma  (delta-eta*phi)]       with phi=phi1+phi2//********************************************{float			Aclass2,Bclass2;struct coeff	coefft;float			disc;int				i;float			khi;float			maxne,maxneprim;float			maxneclass2;float			ne1class2,ne2class2;casechoice:printf("\nWhich convergence case ? (0,1,2 3,4,5) (suggestion: 5): ");scanf("%i",&conv_case);if (conv_case<0 || conv_case>5)	{	printf("\n Wrong value. Le'ts try again");	goto casechoice;	}coefft.c[5]=phi;switch(conv_case)	{	case 0:  // So that x(t+1) = x(t) + v(t+1)		maxne=max_eig_basic(phi);		khi=kappa/maxne; 		coefft.c[0] = khi;		coefft.c[1] = khi;		coefft.c[2] = khi;		coefft.c[3] = (khi+1)*phi-1;		coefft.c[4] = 1;		break;				case 1:  //(proved case)		maxne=max_eig_basic(phi);		khi=kappa/maxne; //********* to change according to the syggestion given                      	//by the program                     	// khi=kappa/maxne for sure convergence		coefft.c[0] = khi;		coefft.c[1] = khi;		coefft.c[2] = khi;		coefft.c[3] = khi;		coefft.c[4] = khi;		break;	case 2: //(just for phi>=4) //(proved case)		if (phi>=4) 			{			disc=sqrt(phi*phi-4*phi);			Aclass2=3/2-(3/4)*phi+(3/4)*disc-(1/2)*(phi*phi)+(1/4)*(phi*phi*phi)-(3/4)*(phi*phi)*disc;			Bclass2=(1/4)*abs(2-phi-2*(phi*phi)+phi*phi*phi+disc-3*phi*phi*disc);			ne1class2=abs(Aclass2+Bclass2);			ne2class2=abs(Aclass2-Bclass2);			maxneclass2=ne2class2;			if(ne1class2>ne2class2)				maxneclass2=ne1class2;			khi=kappa/maxneclass2;     //khi=kappa/maxneclass2 for sure convergence					coefft.c[3]=khi*(2-phi+disc)/2;			coefft.c[2]=khi*(2-phi+3*disc)/(4*phi);			coefft.c[0]=2*coefft.c[3];			coefft.c[1]=coefft.c[0];			coefft.c[4]=2*coefft.c[2];			}		else			{			printf("\n For this case, you must have phi>=4. But here you have phi = %f",phi);			goto casechoice;			}		break;	case 3: //(experimental case)		maxne=max_eig_basic(phi);		khi=kappa/maxne;   //to begin, but not sure convergence		printf("\n Initial khi: %f",khi);  		 withkhi:		if(khi>almostzero) 			{			coefft.c[0]=1;			coefft.c[1]=1;			coefft.c[2]=khi;			coefft.c[3]=khi*khi;			coefft.c[4]=khi*khi;			maxneprim=max_eig(coefft,phi);			if (maxneprim>1)				{				khi=0.9*khi;				goto withkhi;				}			}		else			{			printf("\n No possible convergence");			printf("\n You should change some parameters (phi1, phi2)");			goto casechoice;			}		printf("\n    Final khi (which is used): %f",khi);		break;		case 4: //Called type 1' in the theoretical paper		maxne=max_eig_basic(phi);		khi=kappa/maxne; 		coefft.c[0] = khi;		coefft.c[1] = khi;		coefft.c[2] = 1;		coefft.c[3] = 1;		coefft.c[4] =1;		break;				case 5:  // So that x(t+1) = p + v(t+1)		maxne=max_eig_basic(phi);		khi=kappa/maxne; 		coefft.c[0] = khi;		coefft.c[1] = khi;		coefft.c[2] = khi;		coefft.c[3] = (1-khi)*phi;		//coefft.c[3] = (1-khi)*phi/2;  When phi is random ?		coefft.c[4] = 1;		break;				default:	break;	} 	printf("\n Coeffs:");	for (i=0;i<5;i++)		printf(" %f", coefft.c[i]);	return coefft;}	